def findInvalidIDPartOne(strTest: str):
    # n = len(strTest)
    # if n < 2:  # A pattern needs at least two repetitions to be considered
    #     return ""

    # arrRepeatedPattern = []
    
    # # Iterate through possible lengths of the repeating pattern
    # # The pattern length can be from 1 up to half the string's length
    # for length in range(1, n // 2 + 1):
    #     if n % length == 0:  # Check if the string length is a multiple of the potential pattern length
    #         potential_pattern = strTest[:length]  # Extract the potential pattern
            
    #         # Construct the full string by repeating the potential pattern
    #         repeated_string = potential_pattern * (n // length)
            


    #         # If the constructed string matches the original string, we found the pattern
    #         if repeated_string == strTest:
    #             if(len(repeated_string) != len(strTest)):
    #                 # if(not strTest.startswith(repeated_string)):
    #                 return repeated_string

    strInvalidID = ""

    intFullLength = len(strTest)

    if (intFullLength % 2 == 0):
        intMiddle = int(intFullLength/2)

        strFirstHalf = strTest[:intMiddle]
        strLastHalf = strTest[intMiddle:]

        if(strFirstHalf == strLastHalf):
            strInvalidID = strTest

    return strInvalidID

def findInvalidIDPartTwo(strTest: str):
    strInvalidID = ""
    n = len(strTest)

    # Iterate through possible lengths of the repeating pattern
    # The pattern length can be from 1 up to half the string's length
    for length in range(1, n // 2 + 1):
        if n % length == 0:  # Check if the string length is a multiple of the potential pattern length
            potential_pattern = strTest[:length]  # Extract the potential pattern
            
            # Construct the full string by repeating the potential pattern
            repeated_string = potential_pattern * (n // length)

            # If the constructed string matches the original string, we found the pattern
            if repeated_string == strTest:
                strInvalidID = repeated_string
                break
                
    return strInvalidID


def FillAndTestPatternArray(strProductRange: str, intProblemPart: int):
    intDashLocation = int(strProductRange.find('-'))
    intLowLimit = int(strProductRange[:intDashLocation])
    intHighLimit = int(strProductRange[intDashLocation + 1:])

    arrInvalidIDForRange = []

    arrFullRange = []
    intRangeItemToAddToArray = intLowLimit
    while intRangeItemToAddToArray <= intHighLimit:
        arrFullRange.append(intRangeItemToAddToArray)
        intRangeItemToAddToArray+=1

    for TestString in arrFullRange:
        if(intProblemPart == 1):
            strRepeatedPattern = findInvalidIDPartOne(str(TestString))
        else:
            strRepeatedPattern = findInvalidIDPartTwo(str(TestString))

        if(len(strRepeatedPattern) > 0):
            arrInvalidIDForRange.append(strRepeatedPattern)

    return arrInvalidIDForRange

def solvePartOne(strFullProductList: str):
    arrProductRanges = strFullProductList.split(",")

    arrAllInvalidID = []
    for strTestRange in arrProductRanges:
        arrInvalidIDForRange = FillAndTestPatternArray(strTestRange, 1)

        if (len(arrInvalidIDForRange) > 0):
            arrAllInvalidID.extend(arrInvalidIDForRange)

    intSumInvalidIDs = 0

    for invalidID in arrAllInvalidID:
        intSumInvalidIDs += int(invalidID)

    print(f"Answer For Part One: {intSumInvalidIDs}")

def solvePartTwo(strFullProductList: str):
    arrProductRanges = strFullProductList.split(",")

    arrAllInvalidID = []
    for strTestRange in arrProductRanges:
        arrInvalidIDForRange = FillAndTestPatternArray(strTestRange, 2)

        if (len(arrInvalidIDForRange) > 0):
            arrAllInvalidID.extend(arrInvalidIDForRange)


    # print(arrAllInvalidID)
    intSumInvalidIDs = 0

    for invalidID in arrAllInvalidID:
        intSumInvalidIDs += int(invalidID)

    print(f"Answer For Part Two: {intSumInvalidIDs}")


# ACTUAL VALUES
strFullProducts = ''

solvePartOne(strFullProducts)
solvePartTwo(strFullProducts)


